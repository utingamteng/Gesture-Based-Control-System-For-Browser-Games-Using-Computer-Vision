<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gesture → Keyboard (client-side demo)</title>

<!-- MediaPipe Hands via CDN -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
  body{font-family:Inter,system-ui,Arial;display:flex;gap:18px;padding:18px;background:#0f1724;color:#e6eef8}
  .left{width:520px}
  .right{flex:1;min-width:320px}
  canvas{background:#000;border-radius:8px;display:block}
  .hud{background:#0b1220;padding:12px;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.5)}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  label{font-size:13px;color:#c6d3e9}
  button,select,input[type="range"]{cursor:pointer}
  .big{font-size:18px;font-weight:700}
  .small{font-size:12px;color:#98a7bf}
  .preset{margin-right:6px}
  .led{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
  .maptable{width:100%;border-collapse:collapse;margin-top:8px}
  .maptable td{padding:6px;border-bottom:1px solid #0e2134}
  .warning{background:#3b2416;padding:8px;border-radius:6px;color:#ffd7c0;margin-top:8px}
  .footer{font-size:12px;color:#98a7bf;margin-top:10px}
  a{color:#7dd3fc}
</style>
</head>
<body>

<div class="left">
  <canvas id="videoCanvas" width="480" height="360"></canvas>
  <div class="hud" style="margin-top:8px;">
    <div class="row"><div class="big">Detected: <span id="gesture" style="color:#7fffd4">—</span></div></div>
    <div class="row small"><label>Mode:</label>
      <select id="mode"><option value="tap">Tap</option><option value="hold">Hold</option></select>
      <label style="margin-left:12px">Smoothing:</label>
      <input id="smoothing" type="range" min="1" max="7" value="3" style="width:110px;margin-left:6px"/>
      <span id="smoothingVal" class="small" style="margin-left:6px">3</span>
      <label style="margin-left:12px">Confidence:</label>
      <input id="minConfidence" type="range" min="0.2" max="0.95" step="0.01" value="0.6" style="width:120px;margin-left:6px"/>
      <span id="confVal" class="small" style="margin-left:6px">0.60</span>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="presetFast" class="preset">Fast</button>
      <button id="presetBalanced" class="preset">Balanced</button>
      <button id="presetStable" class="preset">Stable</button>
      <button id="focusGame" style="margin-left:auto">Focus: Click game tab before play</button>
    </div>

    <div style="margin-top:8px">
      <div class="small">Live mapping (gesture → key). You can edit keys: use 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ' (space).</div>
      <table class="maptable">
        <tr><td>High Five</td><td><input class="mapinput" data-gesture="High Five" value="ArrowUp"></td></tr>
        <tr><td>Two</td><td><input class="mapinput" data-gesture="Two" value="ArrowDown"></td></tr>
        <tr><td>Thumb</td><td><input class="mapinput" data-gesture="Thumb" value="ArrowLeft"></td></tr>
        <tr><td>Pinky</td><td><input class="mapinput" data-gesture="Pinky" value="ArrowRight"></td></tr>
        <tr><td>Flat</td><td><input class="mapinput" data-gesture="Flat" value=" "></td></tr>
      </table>
    </div>

    <div style="margin-top:10px" class="small">
      <b>Recent votes:</b> <span id="recentBar">—</span>
    </div>

    <div class="warning small" id="demoNote" style="display:none">
      Demo mode: WebSocket not connected. If you want the browser to forward events to a local Python helper (pyautogui), run the helper and click "Connect local helper".
    </div>

    <div style="margin-top:8px" class="row">
      <button id="connectLocal">Connect local helper (optional)</button>
      <input id="wsUrl" value="ws://localhost:8765" style="flex:1;margin-left:8px" />
    </div>
    <div class="footer">Tip: click your game tab/window to focus it before playing. Some sites ignore synthetic events; use local helper or browser extension for stubborn pages.</div>
  </div>
</div>

<div class="right">
  <div class="hud">
    <div class="row"><div class="big">Calibration & Test</div></div>
    <div class="row small">
      <button id="startCal">Start quick calibration</button>
      <button id="testTap" style="margin-left:6px">Test current mapping</button>
    </div>
    <div style="margin-top:8px" class="small">Calibration records a few frames per gesture to provide a basic sanity filter. It does not train a model. Use it to reduce noise.</div>

    <div style="margin-top:12px">
      <h4 class="small">Smoothing preview</h4>
      <div id="smoothingPreview" class="small">—</div>
    </div>

    <div style="margin-top:12px">
      <h4 class="small">Notes</h4>
      <ul class="small">
        <li>Client-side only: webcam stays on your browser.</li>
        <li>If a site ignores synthetic KeyboardEvent, install the browser extension or run the local helper (code provided below).</li>
        <li>Works best on Chrome/Edge. Firefox can be quirking about synthetic events.</li>
      </ul>
    </div>
  </div>
</div>

<script>
/* ---------- utils & config ---------- */
const canvas = document.getElementById('videoCanvas');
const ctx = canvas.getContext('2d');
const gestureText = document.getElementById('gesture');
const smoothingSlider = document.getElementById('smoothing');
const smoothingVal = document.getElementById('smoothingVal');
const confSlider = document.getElementById('minConfidence');
const confVal = document.getElementById('confVal');
const recentBar = document.getElementById('recentBar');
const mapInputs = document.querySelectorAll('.mapinput');
const modeSelect = document.getElementById('mode');
const wsUrlInput = document.getElementById('wsUrl');
const connectLocalBtn = document.getElementById('connectLocal');

let smoothing = parseInt(smoothingSlider.value);
let minConfidence = parseFloat(confSlider.value);
let holdMode = false;
let ws = null;
let heldKey = null;
let recentLabels = [];
let votes = {};
let lastSent = 0;
const COOLDOWN_MS = 120; // minimal cadence for sending tap events
const MAP = {
  "High Five": "ArrowUp",
  "Two": "ArrowDown",
  "Thumb": "ArrowLeft",
  "Pinky": "ArrowRight",
  "Flat": " "
};

/* update UI from sliders */
smoothingSlider.oninput = ()=>{smoothing = parseInt(smoothingSlider.value); smoothingVal.innerText = smoothing; recentLabels=[];}
confSlider.oninput = ()=>{minConfidence = parseFloat(confSlider.value); confVal.innerText = minConfidence.toFixed(2);}

/* live mapping editor */
mapInputs.forEach(inp=>{
  inp.addEventListener('change', e=>{
    const g = e.target.dataset.gesture;
    MAP[g] = e.target.value;
  });
});

/* presets */
document.getElementById('presetFast').onclick = ()=>{
  smoothingSlider.value = 1; smoothingVal.innerText=1; confSlider.value=0.45; confVal.innerText=0.45;
};
document.getElementById('presetBalanced').onclick = ()=>{
  smoothingSlider.value = 3; smoothingVal.innerText=3; confSlider.value=0.6; confVal.innerText=0.6;
};
document.getElementById('presetStable').onclick = ()=>{
  smoothingSlider.value = 5; smoothingVal.innerText=5; confSlider.value=0.7; confVal.innerText=0.7;
};

/* focus helper */
document.getElementById('focusGame').onclick = ()=>{
  alert('Before playing: click the game tab or window which should receive keyboard events. This page will dispatch keys to whatever is currently focused.');
};

/* test mapping button */
document.getElementById('testTap').onclick = ()=>{
  // quick test: send each mapping as a tap sequentially
  const gestures = Object.keys(MAP);
  let i=0;
  const id = setInterval(()=>{
    const g = gestures[i%gestures.length];
    sendKeySim(MAP[g], 'tap');
    gestureText.innerText = `TEST ${g}`;
    i++;
    if(i>gestures.length*1.2) { clearInterval(id); gestureText.innerText='—'; }
  }, 350);
};

/* Connect local ws helper */
connectLocalBtn.onclick = async ()=>{
  const url = wsUrlInput.value.trim();
  if(ws && ws.readyState === WebSocket.OPEN){ ws.close(); connectLocalBtn.innerText='Connect local helper'; return; }
  try {
    ws = new WebSocket(url);
    ws.onopen = ()=>{ connectLocalBtn.innerText='Disconnect local helper'; document.getElementById('demoNote').style.display='none'; alert('Connected to local helper'); };
    ws.onclose = ()=>{ connectLocalBtn.innerText='Connect local helper'; document.getElementById('demoNote').style.display='block'; };
    ws.onerror = (e)=>{ alert('WS error: could not connect to local helper'); document.getElementById('demoNote').style.display='block'; };
  } catch(e){ alert('Cannot open WebSocket: '+e); }
};

/* ---------- MediaPipe setup ---------- */
const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);

const video = document.createElement('video');
video.playsInline = true;
let camera = null;
async function startCamera(){
  const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }});
  video.srcObject = stream;
  await video.play();
  camera = new Camera(video, { onFrame: async ()=>{ await hands.send({image: video}); }, width: 640, height: 480 });
  camera.start();
}
startCamera().catch(e=>{ alert('Camera error: '+e); });

/* ---------- simple classifier (landmark heuristics) ---------- */
/* This is intentionally simple. Replace with TFJS classifier if you want ML-grade accuracy. */
function classifyLandmarks(lm){
  if(!lm || lm.length<21) return null;
  // just use tip positions
  const thumb = lm[4], index = lm[8], middle = lm[12], ring = lm[16], pinky = lm[20];
  // distances (normalized)
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  const ti = dist(thumb,index);
  const im = dist(index,middle);
  const ip = dist(index,pinky);

  // heuristics
  if(ti>0.10 && im>0.06 && ip>0.09) return "Flat";            // open palm
  if(ti>0.10 && im<0.035) return "Thumb";                    // thumb extended
  if(ip>0.11) return "Pinky";
  if(index.y < middle.y && Math.abs(index.x-middle.x) < 0.06) return "Two";
  return "High Five";
}

/* ---------- smoothing + majority voting ---------- */
function pushLabel(lbl){
  if(recentLabels.length >= smoothing) recentLabels.shift();
  recentLabels.push(lbl);
  // tally counts
  votes = recentLabels.reduce((acc,l)=>{ acc[l]=(acc[l]||0)+1; return acc; }, {});
  recentBar.innerText = Object.entries(votes).map(([k,v])=>`${k}:${v}`).join(' | ');
  // majority
  let sorted = Object.entries(votes).sort((a,b)=>b[1]-a[1]);
  return sorted.length?sorted[0][0]:'none';
}

/* ---------- event sending ---------- */
function sendKeySim(key, type='tap'){
  if(!key) return;
  // send to local helper if connected
  if(ws && ws.readyState===WebSocket.OPEN){
    // message format: {cmd:'tap'/'hold'/'release',key:'ArrowLeft'}
    ws.send(JSON.stringify({cmd:type, key:key}));
    return;
  }
  // otherwise dispatch synthetic KeyboardEvent to window
  try {
    const k = key===' ' ? ' ' : key;
    if(type==='tap'){
      const kd = new KeyboardEvent('keydown',{key:k,bubbles:true,cancelable:true});
      const ku = new KeyboardEvent('keyup',{key:k,bubbles:true,cancelable:true});
      window.dispatchEvent(kd);
      window.dispatchEvent(ku);
    } else if(type==='hold'){
      if(!heldKey){
        const kd = new KeyboardEvent('keydown',{key:k,bubbles:true,cancelable:true});
        window.dispatchEvent(kd);
        heldKey = k;
      }
    } else if(type==='release'){
      if(heldKey){
        const ku = new KeyboardEvent('keyup',{key:heldKey,bubbles:true,cancelable:true});
        window.dispatchEvent(ku);
        heldKey = null;
      }
    }
  } catch(e){
    console.warn('Dispatch failed', e);
  }
}

/* ---------- main callback ---------- */
let lastGesture = 'none';
function onResults(results){
  // draw video
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

  let detected = 'none';
  if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
    const lm = results.multiHandLandmarks[0];
    // draw landmarks
    ctx.fillStyle = '#7fffd4';
    for(const p of lm) ctx.fillRect(p.x*canvas.width-3, p.y*canvas.height-3, 6, 6);

    // classification by landmark heuristics
    const cls = classifyLandmarks(lm);
    detected = cls;
  }

  // smoothing
  const majority = pushLabel(detected);
  gestureText.innerText = majority === 'none' ? '—' : majority;

  // decision & sending
  const now = Date.now();
  const mappedKey = MAP[majority] || null;
  const mode = modeSelect.value;
  if(mappedKey && majority!=='none'){
    if(mode==='tap'){
      if(now - lastSent > COOLDOWN_MS){
        sendKeySim(mappedKey, 'tap'); lastSent = now;
      }
    } else { // hold
      if(majority !== lastGesture){
        // switch held key
        if(heldKey) sendKeySim(heldKey, 'release');
        sendKeySim(mappedKey, 'hold');
      }
    }
  } else {
    // no gesture -> release if held
    if(mode==='hold' && heldKey){ sendKeySim(heldKey, 'release'); }
  }
  lastGesture = majority;

  ctx.restore();
}

/* ---------- quick calibration (toy) ---------- */
document.getElementById('startCal').onclick = async ()=>{
  alert('Calibration will record a few frames of your hand for each gesture listed. Click OK and perform each gesture when prompted.');
  const gestures = Object.keys(MAP);
  for(const g of gestures){
    alert(`Prepare: perform gesture "${g}" (press OK when ready). Will record for 1 second.`);
    // record for 1s
    const start = Date.now(), rec=[];
    while(Date.now()-start < 1000){
      await new Promise(r=>setTimeout(r,120));
      // sample last majority
      rec.push(recentLabels[recentLabels.length-1] || 'none');
    }
    // show summary
    const counts = rec.reduce((a,x)=>{a[x]=(a[x]||0)+1;return a;},{});
    console.log('calib', g, counts);
  }
  alert('Calibration finished (quick). Consider using Stable preset if noisy.');
};

/* ---------- initial UI state ---------- */
document.getElementById('demoNote').style.display = 'block';
smoothingVal.innerText = smoothing;
confVal.innerText = minConfidence.toFixed(2);
</script>
</body>
</html>
